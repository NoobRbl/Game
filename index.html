<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Anime Battle (Original) - Online 1v1</title>

  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #wrap{position:fixed;inset:0;touch-action:none}
    canvas{position:absolute;inset:0}

    /* 16:9 hint overlay when portrait */
    #rotateHint{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.75);color:#fff;text-align:center;padding:24px;z-index:50
    }
    @media (orientation:portrait){
      #rotateHint{display:flex}
    }

    /* top HUD */
    #hud{
      position:absolute;left:0;right:0;top:0;z-index:20;
      display:flex;gap:10px;align-items:center;justify-content:center;
      padding:10px 10px 0 10px;pointer-events:none
    }
    .barWrap{width:min(42vw,520px);height:14px;background:rgba(255,255,255,.10);border-radius:999px;overflow:hidden}
    .barFill{height:100%;width:50%}
    #hudText{color:#fff;font-weight:700;text-shadow:0 2px 10px rgba(0,0,0,.7);opacity:.9}

    /* lobby panel */
    #panel{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(520px,92vw);
      background:rgba(10,14,24,.86);backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;padding:16px;z-index:30;color:#fff
    }
    #panel h2{margin:0 0 10px 0;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input{
      flex:1;min-width:180px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      border-radius:12px;color:#fff;padding:12px 12px;outline:none
    }
    button{
      background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.14);
      color:#fff;border-radius:12px;padding:12px 14px;font-weight:700
    }
    button:active{transform:translateY(1px)}
    #share{margin-top:10px;font-size:13px;opacity:.9;line-break:anywhere}
    #status{margin-top:8px;font-size:13px;opacity:.9}

    /* controls */
    #ui{
      position:absolute;inset:0;z-index:10;pointer-events:none;
    }
    #joyL{
      position:absolute;left:18px;bottom:18px;width:150px;height:150px;
      border-radius:999px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      pointer-events:auto;
    }
    #stickL{
      position:absolute;left:50%;top:50%;width:70px;height:70px;
      transform:translate(-50%,-50%);
      border-radius:999px;background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
    }

    .btnGrid{
      position:absolute;right:18px;bottom:18px;display:grid;
      grid-template-columns: 92px 92px;
      grid-auto-rows: 92px;
      gap:12px;pointer-events:auto;
    }
    .btn{
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      border-radius:16px;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color:#fff;font-weight:800;user-select:none;
      box-shadow:0 12px 30px rgba(0,0,0,.35);
    }
    .btn small{opacity:.75;font-weight:700;margin-top:6px}
    .btn:active{transform:translateY(1px)}
    .btn.big{grid-column: span 2}
    #hintKeys{
      position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
      color:rgba(255,255,255,.55);font-size:12px;z-index:12;pointer-events:none
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>

  <div id="rotateHint">
    <div>
      <div style="font-size:18px;font-weight:800;margin-bottom:10px">Hãy xoay ngang để chơi 16:9</div>
      <div style="opacity:.85">Game sẽ letterbox 16:9, joystick + nút ở dưới.</div>
    </div>
  </div>

  <div id="hud">
    <div class="barWrap"><div id="hpL" class="barFill"></div></div>
    <div id="hudText">OFFLINE</div>
    <div class="barWrap"><div id="hpR" class="barFill"></div></div>
  </div>

  <div id="panel">
    <h2>Online 1v1</h2>
    <div class="row">
      <button id="hostBtn">HOST</button>
      <button id="genBtn">GEN LINK</button>
      <input id="roomInp" placeholder="Nhập ROOM (hoặc dán link)" />
      <button id="joinBtn">JOIN</button>
    </div>
    <div id="share"></div>
    <div id="status">Tip: bạn bè chỉ cần mở đúng link là vào luôn.</div>
  </div>

  <div id="ui">
    <div id="joyL"><div id="stickL"></div></div>

    <div class="btnGrid">
      <div class="btn" id="bUlt">ULT<small>O</small></div>
      <div class="btn" id="bJump">JUMP<small>K</small></div>

      <div class="btn" id="bSub">SUB<small>P</small></div>
      <div class="btn" id="bS2">S2<small>I</small></div>

      <div class="btn" id="bS1">S1<small>U</small></div>
      <div class="btn" id="bDash">DASH<small>L</small></div>

      <div class="btn big" id="bAtk">ATK<small>J</small></div>
    </div>

    <div id="hintKeys">WASD / Joystick • ATK J • JUMP K • DASH L • S1 U • S2 I • ULT O • SUB P</div>
  </div>
</div>

<!-- socket.io from server -->
<script src="/socket.io/socket.io.js"></script>

<script>
/* =========================
   0) Small helpers
========================= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function parseRoomFromHash(){
  const h = location.hash.replace("#","").trim();
  // accept #ROOM=XXXXXX or #XXXXXX
  if(!h) return "";
  if(h.toUpperCase().startsWith("ROOM=")) return h.slice(5).toUpperCase();
  return h.toUpperCase();
}
function setHashRoom(r){
  location.hash = "ROOM=" + r;
}

/* =========================
   1) Input (fix mượt + one-shot edge)
========================= */
function setupInput(){
  const keys = new Set();
  addEventListener("keydown",(e)=>keys.add(e.key.toLowerCase()),{passive:true});
  addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()),{passive:true});

  const touch={atk:false,dash:false,jump:false,s1:false,s2:false,ult:false,sub:false};

  const bindBtn=(id,name)=>{
    const el=document.getElementById(id);
    const down=(e)=>{ e.preventDefault(); touch[name]=true; };
    const up=(e)=>{ e.preventDefault(); touch[name]=false; };
    el.addEventListener("pointerdown",down,{passive:false});
    el.addEventListener("pointerup",up,{passive:false});
    el.addEventListener("pointercancel",up,{passive:false});
    el.addEventListener("pointerleave",up,{passive:false});
  };
  bindBtn("bAtk","atk"); bindBtn("bDash","dash"); bindBtn("bJump","jump");
  bindBtn("bS1","s1"); bindBtn("bS2","s2"); bindBtn("bUlt","ult"); bindBtn("bSub","sub");

  const joyL=document.getElementById("joyL");
  const stickL=document.getElementById("stickL");
  const joyVec={x:0,y:0};

  (function setupJoy(){
    let active=false,pid=null,center={x:0,y:0};
    const radius=52;

    function setStick(nx,ny){
      // nx,ny in [-1..1]
      const x = nx*radius, y = ny*radius;
      stickL.style.transform=`translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }
    function start(e){
      active=true; pid=e.pointerId;
      const r=joyL.getBoundingClientRect();
      center.x=r.left+r.width/2; center.y=r.top+r.height/2;
      move(e);
    }
    function move(e){
      if(!active||e.pointerId!==pid) return;
      const dx=e.clientX-center.x, dy=e.clientY-center.y;
      const len=Math.hypot(dx,dy)||1;
      const k=Math.min(1,len/radius);
      joyVec.x=(dx/len)*k; joyVec.y=(dy/len)*k;
      setStick(joyVec.x,joyVec.y);
      e.preventDefault();
    }
    function end(e){
      if(!active||e.pointerId!==pid) return;
      active=false; pid=null;
      joyVec.x=0; joyVec.y=0;
      setStick(0,0);
    }
    joyL.addEventListener("pointerdown",(e)=>{
      joyL.setPointerCapture(e.pointerId);
      start(e); e.preventDefault();
    },{passive:false});
    joyL.addEventListener("pointermove",move,{passive:false});
    joyL.addEventListener("pointerup",end,{passive:false});
    joyL.addEventListener("pointercancel",end,{passive:false});
  })();

  const makeInput=()=>({mx:0, atk:false, jump:false, dash:false, s1:false, s2:false, ult:false, sub:false});
  const edgeState=new Map();
  const once=(k,down)=>{
    const prev=edgeState.get(k)||false;
    if(down && !prev){ edgeState.set(k,true); return true; }
    if(!down) edgeState.set(k,false);
    return false;
  };

  function readLocalInput(){
    const inp=makeInput();
    let x=0;
    if(keys.has("a")) x-=1;
    if(keys.has("d")) x+=1;
    // joystick adds analog
    x += joyVec.x*1.05;
    inp.mx = clamp(x, -1, 1);

    inp.atk  = keys.has("j") || touch.atk;
    inp.jump = keys.has("k") || touch.jump;
    inp.dash = keys.has("l") || touch.dash;
    inp.s1   = keys.has("u") || touch.s1;
    inp.s2   = keys.has("i") || touch.s2;
    inp.ult  = keys.has("o") || touch.ult;
    inp.sub  = keys.has("p") || touch.sub;

    return inp;
  }

  return { readLocalInput, once };
}

/* =========================
   2) Render (16:9 letterbox + fighter + FX)
========================= */
function setupRender(){
  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * devicePixelRatio);
    canvas.height = Math.floor(h * devicePixelRatio);
    canvas.style.width = w+"px";
    canvas.style.height = h+"px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  function computeView(){
    const W=innerWidth, H=innerHeight;
    const target=16/9;
    let vw=W, vh=H, ox=0, oy=0;
    if(W/H>target){
      vh=H; vw=H*target; ox=(W-vw)*0.5;
    }else{
      vw=W; vh=W/target; oy=(H-vh)*0.5;
    }
    return {W,H,vw,vh,ox,oy};
  }

  function worldToScreen(view, camX, wx, wy){
    const {ox,oy,vw,vh}=view;
    const scale = vw/1280;
    const sx = ox + vw/2 + (wx-camX)*scale;
    const sy = oy + vh*0.72 + wy*scale;
    return {sx,sy,scale};
  }

  function drawBackground(view){
    const {ox,oy,vw,vh}=view;
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,view.W,view.H); // bars

    const g=ctx.createLinearGradient(0,oy,0,oy+vh);
    g.addColorStop(0,"#0b1020");
    g.addColorStop(1,"#05070f");
    ctx.fillStyle=g; ctx.fillRect(ox,oy,vw,vh);

    // stage
    ctx.fillStyle="rgba(120,150,255,0.06)";
    ctx.fillRect(ox,oy+vh*0.55,vw,vh*0.45);
    ctx.fillStyle="rgba(0,0,0,0.28)";
    ctx.fillRect(ox,oy+vh*0.74,vw,vh*0.02);
  }

  function drawFighter(p, isEnemy, view, camX){
    if(!p) return;
    const wx = Number.isFinite(p.x) ? p.x : 0;
    const wy = Number.isFinite(p.y) ? p.y : 0;
    const face = p.face || 1;

    const sp = worldToScreen(view, camX, wx, wy);
    const {sx,sy,scale} = sp;

    ctx.save();
    ctx.translate(sx,sy);

    // invul flicker
    if(p.invul>0) ctx.globalAlpha = 0.55 + 0.25*Math.sin(performance.now()*0.03);

    // flip
    ctx.scale(face<0?-1:1,1);

    // shadow
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(0, 8*scale, 30*scale, 11*scale, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = isEnemy ? "#ff6a6a" : "#6ad5ff";
    ctx.fillRect(-24*scale, -92*scale, 48*scale, 92*scale);

    // head
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.fillRect(-14*scale, -118*scale, 28*scale, 26*scale);

    // small scarf (assassin vibe)
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.fillRect(-18*scale, -78*scale, 36*scale, 8*scale);

    ctx.restore();
    ctx.globalAlpha=1;
  }

  function drawFX(G, view){
    const camX = G.camX||0;

    // slashes
    for(const s of G.fx.slashes){
      const p = worldToScreen(view, camX, s.wx, s.wy);
      const t = s.t / s.life;
      ctx.save();
      ctx.translate(p.sx, p.sy);
      ctx.rotate(s.rot);
      ctx.globalAlpha = 1 - t;

      // different styles per tag (still lightweight)
      let col="rgba(190,255,255,0.9)";
      if(s.kind==="ult") col="rgba(255,220,140,0.95)";
      if(s.kind==="skill1") col="rgba(180,255,190,0.95)";
      if(s.kind==="skill2") col="rgba(255,190,255,0.95)";
      if(s.kind==="sub") col="rgba(255,255,255,0.85)";
      ctx.fillStyle = col;

      const sc = view.vw/1280;
      ctx.fillRect(-s.len*sc*0.5, -s.w*sc*0.5, s.len*sc, s.w*sc);
      ctx.restore();
    }

    // popups
    ctx.textAlign="center";
    const sc = view.vw/1280;
    ctx.font = `${Math.max(12, 18*sc)}px system-ui,-apple-system,Segoe UI,Roboto`;
    for(const d of G.fx.popups){
      const p = worldToScreen(view, camX, d.wx, d.wy);
      const t = d.t / d.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = d.crit ? "rgba(255,220,120,1)" : "rgba(255,255,255,0.95)";
      ctx.fillText(d.text, p.sx, p.sy);
    }
    ctx.globalAlpha=1;

    // ult cinematic-lite: vignette + flash
    if(G.ultFx && G.ultFx.t < G.ultFx.life){
      const k = 1 - (G.ultFx.t / G.ultFx.life);
      const {ox,oy,vw,vh}=view;
      const grd = ctx.createRadialGradient(ox+vw/2,oy+vh/2,vh*0.2,ox+vw/2,oy+vh/2,vh*0.85);
      grd.addColorStop(0, `rgba(0,0,0,${0.0})`);
      grd.addColorStop(1, `rgba(0,0,0,${0.55*k})`);
      ctx.fillStyle=grd; ctx.fillRect(ox,oy,vw,vh);

      ctx.globalAlpha = Math.min(0.20, 0.20*k);
      ctx.fillStyle="#fff"; ctx.fillRect(ox,oy,vw,vh);
      ctx.globalAlpha=1;
    }
  }

  function drawFrame(G, dt){
    const view = computeView();
    drawBackground(view);

    // fighters
    drawFighter(G.L, false, view, G.camX||0);
    drawFighter(G.R, true, view, G.camX||0);

    // FX time
    for(const s of G.fx.slashes) s.t += dt;
    for(const p of G.fx.popups) p.t += dt;
    G.fx.slashes = G.fx.slashes.filter(s=>s.t < s.life);
    G.fx.popups  = G.fx.popups.filter(p=>p.t < p.life);

    if(G.ultFx){
      G.ultFx.t += dt;
      if(G.ultFx.t >= G.ultFx.life) G.ultFx = null;
    }

    drawFX(G, view);
  }

  return { drawFrame };
}

/* =========================
   3) Net (sync realtime, giảm lag: client interp)
========================= */
function setupNet(){
  const socket = io({
    transports: ["websocket","polling"],
  });

  const net = {
    socket,
    roomId: "",
    side: "",
    pingMs: 0,
    lastSnapAt: 0,
    serverSnap: null,   // latest snap
    smooth: { L:null, R:null, camX:0 }, // interpolated state
  };

  let pingT=0;
  setInterval(()=>{
    pingT = performance.now();
    socket.emit("ping2");
  }, 1500);

  // custom ping
  socket.on("pong2", ()=> net.pingMs = Math.round(performance.now()-pingT));

  // fallback: use socket.io built-in latency 느낌
  socket.io.on("ping", ()=>{});
  socket.io.on("pong", ()=>{});

  return net;
}

/* =========================
   4) Game glue
========================= */
const input = setupInput();
const render = setupRender();
const net = setupNet();

// game state used for drawing (client side)
const G = {
  camX: 0,
  L: {x:-220,y:0,face:1,hp:1,maxHp:1,en:0,invul:0,stun:0},
  R: {x: 220,y:0,face:-1,hp:1,maxHp:1,en:0,invul:0,stun:0},
  fx: { slashes: [], popups: [] },
  ultFx: null
};

// HUD binds
const hpL = document.getElementById("hpL");
const hpR = document.getElementById("hpR");
const hudText = document.getElementById("hudText");
function setBar(el, ratio, left){
  ratio = clamp(ratio,0,1);
  el.style.width = (ratio*100).toFixed(1)+"%";
  // simple gradient via inline
  el.style.background = left ? "linear-gradient(90deg,#49e2ff,#6a7bff)" : "linear-gradient(90deg,#ff6a6a,#ffcf6a)";
}
function updateHud(){
  setBar(hpL, (G.L.hp||0)/(G.L.maxHp||1), true);
  setBar(hpR, (G.R.hp||0)/(G.R.maxHp||1), false);
  hudText.textContent = `FIGHT • ping: ${net.pingMs||0}ms • HP: ${Math.floor(G.L.hp)}/${Math.floor(G.L.maxHp)} vs ${Math.floor(G.R.hp)}/${Math.floor(G.R.maxHp)}`;
}

/* ----- Panel / Room flow ----- */
const panel = document.getElementById("panel");
const hostBtn = document.getElementById("hostBtn");
const genBtn = document.getElementById("genBtn");
const joinBtn = document.getElementById("joinBtn");
const roomInp = document.getElementById("roomInp");
const share = document.getElementById("share");
const status = document.getElementById("status");

function showStatus(t){ status.textContent = t; }

let seq = 0;
let lastInp = null;

hostBtn.onclick = async ()=>{
  // create room on server
  net.socket.emit("room:create", {}, (res)=>{
    if(!res?.ok) return showStatus("Tạo phòng thất bại");
    net.roomId = res.roomId;
    roomInp.value = res.roomId;
    setHashRoom(res.roomId);
    showStatus("Đã HOST. Bấm GEN LINK để lấy link share.");
  });
};

genBtn.onclick = ()=>{
  const r = (roomInp.value||parseRoomFromHash()||net.roomId||"").toUpperCase().trim();
  if(!r) return showStatus("Chưa có ROOM. Bấm HOST trước.");
  const url = location.origin + "/#ROOM=" + r;
  share.innerHTML = `<div><b>Link vào phòng (1 code là vào luôn):</b></div><div>${url}</div>`;
  navigator.clipboard?.writeText(url).catch(()=>{});
  showStatus("Đã copy link (nếu trình duyệt cho phép). Gửi link này cho bạn bè.");
};

joinBtn.onclick = ()=>{
  let v = (roomInp.value||"").trim();
  // if user pasted full link
  if(v.includes("#")) v = v.split("#").pop();
  v = v.replace("ROOM=","").toUpperCase().trim();
  if(!v) return showStatus("Nhập ROOM hoặc dán link rồi bấm JOIN");
  setHashRoom(v);
  joinRoom(v);
};

function joinRoom(roomId){
  net.socket.emit("room:join", {roomId}, (res)=>{
    if(!res?.ok){
      showStatus("JOIN fail: " + (res?.err||"ERR"));
      return;
    }
    net.roomId = res.roomId;
    net.side = res.side;
    panel.style.display = "none";
    showStatus("OK");
  });
}

// auto-join if hash exists
const initialRoom = parseRoomFromHash();
if(initialRoom){
  roomInp.value = initialRoom;
  joinRoom(initialRoom);
}

/* ----- Snap handling (sync) ----- */
net.socket.on("snap", (snap)=>{
  net.serverSnap = snap;
  net.lastSnapAt = performance.now();

  // copy FX from server (already includes popup + slash)
  if(snap.fx){
    // add slashes/popups with fresh timers
    for(const s of (snap.fx.slashes||[])){
      G.fx.slashes.push({...s, t:0});
    }
    for(const p of (snap.fx.popups||[])){
      G.fx.popups.push({...p, t:0});
    }
    if(snap.fx.ult){
      G.ultFx = { t:0, life: snap.fx.ult.life || 0.55 };
    }
  }
});

/* =========================
   5) Main loop (client interp + send inputs)
========================= */
let lastT = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t-lastT)/1000);
  lastT = t;

  // 5.1) read input
  const inp = input.readLocalInput();
  const edge = {
    atk:  input.once("atk",  inp.atk),
    dash: input.once("dash", inp.dash),
    jump: input.once("jump", inp.jump),
    s1:   input.once("s1",   inp.s1),
    s2:   input.once("s2",   inp.s2),
    ult:  input.once("ult",  inp.ult),
    sub:  input.once("sub",  inp.sub),
  };

  // 5.2) send input to server (only if connected/playing)
  if(net.roomId){
    seq++;
    net.socket.emit("inp", { seq, inp, edge });
  }

  // 5.3) interpolate server snapshot to avoid "không đồng bộ cùng lúc"
  if(net.serverSnap){
    const s = net.serverSnap;

    // smooth factor based on time since last snap
    const age = (performance.now() - net.lastSnapAt) / 1000;
    const k = clamp(0.20 + age*0.60, 0.20, 0.65);

    if(s.L){
      if(!G.L) G.L = {...s.L};
      G.L.x = lerp(G.L.x, s.L.x, k);
      G.L.y = lerp(G.L.y, s.L.y, k);
      G.L.face = s.L.face;
      G.L.hp = s.L.hp; G.L.maxHp = s.L.maxHp;
      G.L.en = s.L.en; G.L.invul = s.L.invul; G.L.stun = s.L.stun;
    }
    if(s.R){
      if(!G.R) G.R = {...s.R};
      G.R.x = lerp(G.R.x, s.R.x, k);
      G.R.y = lerp(G.R.y, s.R.y, k);
      G.R.face = s.R.face;
      G.R.hp = s.R.hp; G.R.maxHp = s.R.maxHp;
      G.R.en = s.R.en; G.R.invul = s.R.invul; G.R.stun = s.R.stun;
    }
    G.camX = lerp(G.camX, s.camX || 0, k);
  }

  // 5.4) draw
  render.drawFrame(G, dt);
  updateHud();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== extra: custom ping (optional) ===== */
net.socket.on("connect", ()=>{
  // implement our ping2/pong2 quickly
  net.socket.on("ping2", ()=> net.socket.emit("pong2"));
});
</script>
</body>
</html>
