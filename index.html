<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Anime Battle 2D (Online 1v1)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #wrap{position:fixed;inset:0;touch-action:none}
    canvas{position:absolute;inset:0}

    /* show rotate hint in portrait */
    #rotateHint{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.75);color:#fff;text-align:center;padding:24px;z-index:50
    }
    @media (orientation:portrait){ #rotateHint{display:flex} }

    /* HUD corners */
    #hudL,#hudR,#hudMid{
      position:absolute;top:10px;z-index:20;pointer-events:none;color:#fff;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
      font-weight:900
    }
    #hudL{left:10px;width:min(42vw,520px)}
    #hudR{right:10px;width:min(42vw,520px);text-align:right}
    #hudMid{left:50%;transform:translateX(-50%);top:12px;font-size:14px;opacity:.95}

    .hpWrap,.enWrap{
      height:12px;background:rgba(255,255,255,.10);border-radius:999px;overflow:hidden;
      border:1px solid rgba(255,255,255,.10)
    }
    .hpFill,.enFill{height:100%}
    .label{margin:6px 0 6px 0;font-size:12px;opacity:.9}

    /* lobby panel */
    #panel{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(560px,92vw);
      background:rgba(10,14,24,.86);backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;padding:16px;z-index:30;color:#fff
    }
    #panel h2{margin:0 0 10px 0;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input{
      flex:1;min-width:200px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      border-radius:12px;color:#fff;padding:12px 12px;outline:none
    }
    button{
      background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.14);
      color:#fff;border-radius:12px;padding:12px 14px;font-weight:900
    }
    button:active{transform:translateY(1px)}
    #share{margin-top:10px;font-size:13px;opacity:.95;line-break:anywhere}
    #status{margin-top:8px;font-size:13px;opacity:.9}

    /* controls */
    #ui{position:absolute;inset:0;z-index:10;pointer-events:none}
    #joyL{
      position:absolute;left:18px;bottom:18px;width:150px;height:150px;
      border-radius:999px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      pointer-events:auto;
    }
    #stickL{
      position:absolute;left:50%;top:50%;width:70px;height:70px;
      transform:translate(-50%,-50%);
      border-radius:999px;background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
    }

    .btnGrid{
      position:absolute;right:18px;bottom:18px;display:grid;
      grid-template-columns: 92px 92px;
      grid-auto-rows: 92px;
      gap:12px;pointer-events:auto;
    }
    .btn{
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      border-radius:16px;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color:#fff;font-weight:900;user-select:none;
      box-shadow:0 12px 30px rgba(0,0,0,.35);
    }
    .btn small{opacity:.75;font-weight:800;margin-top:6px}
    .btn:active{transform:translateY(1px)}
    .btn.big{grid-column: span 2}

    #centerText{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      z-index:25;pointer-events:none;
      color:#fff;font-weight:1000;font-size:72px;
      text-shadow:0 8px 30px rgba(0,0,0,.8);
      opacity:0; transition:opacity .12s ease;
    }

    #hintKeys{
      position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
      color:rgba(255,255,255,.55);font-size:12px;z-index:12;pointer-events:none
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>

  <div id="rotateHint">
    <div>
      <div style="font-size:18px;font-weight:1000;margin-bottom:10px">Hãy xoay ngang để chơi 16:9</div>
      <div style="opacity:.85">Joystick + nút sẽ hoạt động mượt trong landscape.</div>
    </div>
  </div>

  <!-- HUD -->
  <div id="hudL">
    <div class="label" id="hpLText">P1 HP</div>
    <div class="hpWrap"><div id="hpL" class="hpFill"></div></div>
    <div style="height:6px"></div>
    <div class="label" id="enLText">P1 EN</div>
    <div class="enWrap"><div id="enL" class="enFill"></div></div>
  </div>

  <div id="hudR">
    <div class="label" id="hpRText">P2 HP</div>
    <div class="hpWrap"><div id="hpR" class="hpFill"></div></div>
    <div style="height:6px"></div>
    <div class="label" id="enRText">P2 EN</div>
    <div class="enWrap"><div id="enR" class="enFill"></div></div>
  </div>

  <div id="hudMid">ping: --ms</div>

  <div id="centerText">3</div>

  <div id="panel">
    <h2>Online 1v1</h2>
    <div class="row">
      <button id="hostBtn">HOST</button>
      <button id="genBtn">GEN LINK</button>
      <input id="roomInp" placeholder="Nhập ROOM (hoặc dán link)" />
      <button id="joinBtn">JOIN</button>
    </div>
    <div id="share"></div>
    <div id="status">Tip: bạn bè chỉ cần mở đúng link là vào luôn.</div>
  </div>

  <div id="ui">
    <div id="joyL"><div id="stickL"></div></div>

    <div class="btnGrid">
      <div class="btn" id="bUlt">ULT<small>O</small></div>
      <div class="btn" id="bJump">JUMP<small>K</small></div>
      <div class="btn" id="bSub">SUB<small>P</small></div>
      <div class="btn" id="bS2">S2<small>I</small></div>
      <div class="btn" id="bS1">S1<small>U</small></div>
      <div class="btn" id="bDash">DASH<small>L</small></div>
      <div class="btn big" id="bAtk">ATK<small>J</small></div>
    </div>

    <div id="hintKeys">WASD / Joystick • ATK J • JUMP K • DASH L • S1 U • S2 I • ULT O • SUB P</div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

function parseRoomFromHash(){
  const h = location.hash.replace("#","").trim();
  if(!h) return "";
  if(h.toUpperCase().startsWith("ROOM=")) return h.slice(5).toUpperCase();
  return h.toUpperCase();
}
function setHashRoom(r){ location.hash = "ROOM=" + r; }

// ===== INPUT =====
function setupInput(){
  const keys = new Set();
  addEventListener("keydown",(e)=>keys.add(e.key.toLowerCase()),{passive:true});
  addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()),{passive:true});

  const touch={atk:false,dash:false,jump:false,s1:false,s2:false,ult:false,sub:false};
  const bindBtn=(id,name)=>{
    const el=document.getElementById(id);
    const down=(e)=>{ e.preventDefault(); touch[name]=true; };
    const up=(e)=>{ e.preventDefault(); touch[name]=false; };
    el.addEventListener("pointerdown",down,{passive:false});
    el.addEventListener("pointerup",up,{passive:false});
    el.addEventListener("pointercancel",up,{passive:false});
    el.addEventListener("pointerleave",up,{passive:false});
  };
  bindBtn("bAtk","atk"); bindBtn("bDash","dash"); bindBtn("bJump","jump");
  bindBtn("bS1","s1"); bindBtn("bS2","s2"); bindBtn("bUlt","ult"); bindBtn("bSub","sub");

  const joyL=document.getElementById("joyL");
  const stickL=document.getElementById("stickL");
  const joyVec={x:0,y:0};

  (function setupJoy(){
    let active=false,pid=null,center={x:0,y:0};
    const radius=52;
    function setStick(nx,ny){
      const x = nx*radius, y = ny*radius;
      stickL.style.transform=`translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }
    function start(e){
      active=true; pid=e.pointerId;
      const r=joyL.getBoundingClientRect();
      center.x=r.left+r.width/2; center.y=r.top+r.height/2;
      move(e);
    }
    function move(e){
      if(!active||e.pointerId!==pid) return;
      const dx=e.clientX-center.x, dy=e.clientY-center.y;
      const len=Math.hypot(dx,dy)||1;
      const k=Math.min(1,len/radius);
      joyVec.x=(dx/len)*k;
      joyVec.y=(dy/len)*k;
      setStick(joyVec.x,joyVec.y);
      e.preventDefault();
    }
    function end(e){
      if(!active||e.pointerId!==pid) return;
      active=false; pid=null;
      joyVec.x=0; joyVec.y=0;
      setStick(0,0);
    }
    joyL.addEventListener("pointerdown",(e)=>{
      joyL.setPointerCapture(e.pointerId);
      start(e); e.preventDefault();
    },{passive:false});
    joyL.addEventListener("pointermove",move,{passive:false});
    joyL.addEventListener("pointerup",end,{passive:false});
    joyL.addEventListener("pointercancel",end,{passive:false});
  })();

  // edge detector
  const edgeState=new Map();
  const once=(k,down)=>{
    const prev=edgeState.get(k)||false;
    if(down && !prev){ edgeState.set(k,true); return true; }
    if(!down) edgeState.set(k,false);
    return false;
  };

  function readLocalInput(){
    let x=0;
    if(keys.has("a")) x-=1;
    if(keys.has("d")) x+=1;
    x += joyVec.x*1.05;
    x = clamp(x,-1,1);
    return {
      mx:x,
      atk:  keys.has("j") || touch.atk,
      jump: keys.has("k") || touch.jump,
      dash: keys.has("l") || touch.dash,
      s1:   keys.has("u") || touch.s1,
      s2:   keys.has("i") || touch.s2,
      ult:  keys.has("o") || touch.ult,
      sub:  keys.has("p") || touch.sub,
    };
  }

  return { readLocalInput, once };
}

// ===== RENDER =====
function setupRender() {
  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resize(){
    const w=innerWidth, h=innerHeight;
    canvas.width = Math.floor(w*devicePixelRatio);
    canvas.height= Math.floor(h*devicePixelRatio);
    canvas.style.width=w+"px";
    canvas.style.height=h+"px";
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener("resize",resize,{passive:true});
  resize();

  // 16:9 letterbox
  function computeView(){
    const W=innerWidth, H=innerHeight;
    const target=16/9;
    let vw=W, vh=H, ox=0, oy=0;
    if(W/H>target){ vh=H; vw=H*target; ox=(W-vw)*0.5; }
    else { vw=W; vh=W/target; oy=(H-vh)*0.5; }
    return {W,H,vw,vh,ox,oy};
  }

  function worldToScreen(view, camX, zoom, wx, wy){
    const {ox,oy,vw,vh}=view;
    const base = vw/1280;
    const scale = base*(zoom??1);
    const sx = ox + vw/2 + (wx-camX)*scale;
    const sy = oy + vh*0.72 + wy*scale;
    return {sx,sy,scale};
  }

  // prettier platform-style map
  function drawBackground(view){
    const {ox,oy,vw,vh}=view;

    // sky gradient
    const g = ctx.createLinearGradient(0,oy,0,oy+vh);
    g.addColorStop(0,"#0a1636");
    g.addColorStop(1,"#03050b");
    ctx.fillStyle=g;
    ctx.fillRect(ox,oy,vw,vh);

    // distant mountains
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "#6aa7ff";
    for(let i=0;i<5;i++){
      const x = ox + (i/4)*vw;
      ctx.beginPath();
      ctx.moveTo(x-120, oy+vh*0.55);
      ctx.lineTo(x+140, oy+vh*0.35);
      ctx.lineTo(x+380, oy+vh*0.55);
      ctx.closePath();
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // mid fog layer
    ctx.fillStyle="rgba(255,255,255,0.05)";
    ctx.fillRect(ox, oy+vh*0.50, vw, vh*0.10);

    // main ground platform
    ctx.fillStyle="rgba(120,150,255,0.10)";
    ctx.fillRect(ox, oy+vh*0.60, vw, vh*0.40);

    // platform top line
    ctx.fillStyle="rgba(255,255,255,0.08)";
    ctx.fillRect(ox, oy+vh*0.72, vw, 2);

    // decorative pillars
    ctx.fillStyle="rgba(255,255,255,0.06)";
    for(let i=0;i<6;i++){
      const x = ox + (0.12 + i*0.14)*vw;
      ctx.fillRect(x, oy+vh*0.62, 10, vh*0.18);
    }

    // side walls visual
    ctx.fillStyle="rgba(255,255,255,0.06)";
    ctx.fillRect(ox+vw*0.06, oy+vh*0.60, 6, vh*0.40);
    ctx.fillRect(ox+vw*0.94, oy+vh*0.60, 6, vh*0.40);

    // subtle vignette bottom
    const v = ctx.createLinearGradient(0, oy+vh*0.70, 0, oy+vh);
    v.addColorStop(0,"rgba(0,0,0,0)");
    v.addColorStop(1,"rgba(0,0,0,0.35)");
    ctx.fillStyle=v;
    ctx.fillRect(ox,oy,vw,vh);
  }

  function drawFighter(sx,sy,face,isEnemy,scale,invul){
    ctx.save();
    ctx.translate(sx,sy);
    const sizeMul=0.78;
    ctx.scale(sizeMul, sizeMul);
    if(invul>0) ctx.globalAlpha = 0.55 + 0.25*Math.sin(performance.now()*0.03);
    ctx.scale(face<0?-1:1,1);

    // shadow
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(0,6*scale,28*scale,10*scale,0,0,Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle=isEnemy?"#ff6a6a":"#6ad5ff";
    ctx.fillRect(-24*scale,-92*scale,48*scale,92*scale);

    // head
    ctx.fillStyle="rgba(255,255,255,0.85)";
    ctx.fillRect(-14*scale,-118*scale,28*scale,26*scale);

    // eye
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.fillRect(-8*scale,-108*scale,16*scale,3*scale);

    ctx.restore();
    ctx.globalAlpha=1;
  }

  function drawFX(view,camX,zoom,fx){
    const scaleBase=(view.vw/1280)*(zoom??1);

    for(const s of fx.slashes){
      const p=worldToScreen(view,camX,zoom,s.wx,s.wy);
      const t=s.t/s.life;
      ctx.save();
      ctx.translate(p.sx,p.sy);
      ctx.rotate(s.rot);
      ctx.globalAlpha=1-t;

      let col="rgba(190,255,255,0.90)";
      if(s.kind==="ult") col="rgba(255,220,140,0.95)";
      if(s.kind==="skill1") col="rgba(180,255,190,0.95)";
      if(s.kind==="skill2") col="rgba(255,190,255,0.95)";
      if(s.kind==="sub") col="rgba(255,255,255,0.85)";
      ctx.fillStyle=col;

      ctx.fillRect(-s.len*scaleBase*0.5,-s.w*scaleBase*0.5,s.len*scaleBase,s.w*scaleBase);
      ctx.restore();
    }

    for(const sp of fx.sparks){
      const p=worldToScreen(view,camX,zoom,sp.wx,sp.wy);
      const t=sp.t/sp.life;
      ctx.globalAlpha=1-t;
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.fillRect(p.sx,p.sy,sp.s*scaleBase,sp.s*scaleBase);
    }

    ctx.textAlign="center";
    ctx.font=`${Math.max(12,16*scaleBase)}px system-ui,-apple-system,Segoe UI,Roboto`;
    for(const d of fx.popups){
      const p=worldToScreen(view,camX,zoom,d.wx,d.wy);
      const t=d.t/d.life;
      ctx.globalAlpha=1-t;
      ctx.fillStyle=d.crit?"rgba(255,220,120,1)":"rgba(255,255,255,0.95)";
      ctx.fillText(d.text,p.sx,p.sy);
    }
    ctx.globalAlpha=1;
  }

  function drawFrame(G,dt){
    const view=computeView();
    const {W,H,ox,oy,vw,vh}=view;

    // black bars
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);

    ctx.save();
    drawBackground(view);

    const camX=G.camX||0;
    const zoom=G.zoom??1;

    if(G.Left){
      const p=worldToScreen(view,camX,zoom,G.Left.x,G.Left.y);
      drawFighter(p.sx,p.sy,G.Left.face,false,p.scale,G.Left.invul);
    }
    if(G.Right){
      const p=worldToScreen(view,camX,zoom,G.Right.x,G.Right.y);
      drawFighter(p.sx,p.sy,G.Right.face,true,p.scale,G.Right.invul);
    }

    drawFX(view,camX,zoom,G.fx);

    ctx.restore();
  }

  return { drawFrame };
}

// ===== NET + GAME =====
const input = setupInput();
const render = setupRender();
const socket = io({ transports:["websocket","polling"] });

const G = {
  camX:0, zoom:1,
  Left:null, Right:null,
  fx:{ slashes:[], popups:[], sparks:[] },
  phase:"lobby", cdText:""
};

// HUD elems
const hpL=document.getElementById("hpL");
const hpR=document.getElementById("hpR");
const enL=document.getElementById("enL");
const enR=document.getElementById("enR");
const hudMid=document.getElementById("hudMid");
const hpLText=document.getElementById("hpLText");
const hpRText=document.getElementById("hpRText");
const enLText=document.getElementById("enLText");
const enRText=document.getElementById("enRText");

function setBar(el, ratio, grad){
  ratio=clamp(ratio,0,1);
  el.style.width=(ratio*100).toFixed(1)+"%";
  el.style.background=grad;
}
function updateHud(pingMs){
  const L=G.Left, R=G.Right;
  if(!L||!R){
    hudMid.textContent=`ping: ${pingMs}ms • waiting...`;
    setBar(hpL,0,"linear-gradient(90deg,#49e2ff,#6a7bff)");
    setBar(hpR,0,"linear-gradient(90deg,#ff6a6a,#ffcf6a)");
    setBar(enL,0,"linear-gradient(90deg,#7cffb2,#3cffef)");
    setBar(enR,0,"linear-gradient(90deg,#7cffb2,#3cffef)");
    return;
  }
  hudMid.textContent=`ping: ${pingMs}ms`;

  hpLText.textContent=`P1 HP: ${Math.floor(L.hp)}/${Math.floor(L.maxHp)}`;
  hpRText.textContent=`P2 HP: ${Math.floor(R.hp)}/${Math.floor(R.maxHp)}`;
  enLText.textContent=`P1 EN: ${Math.floor(L.en)}%`;
  enRText.textContent=`P2 EN: ${Math.floor(R.en)}%`;

  setBar(hpL,(L.hp||0)/(L.maxHp||1),"linear-gradient(90deg,#49e2ff,#6a7bff)");
  setBar(hpR,(R.hp||0)/(R.maxHp||1),"linear-gradient(90deg,#ff6a6a,#ffcf6a)");
  setBar(enL,(L.en||0)/100,"linear-gradient(90deg,#7cffb2,#3cffef)");
  setBar(enR,(R.en||0)/100,"linear-gradient(90deg,#7cffb2,#3cffef)");
}

// countdown center text
const centerText=document.getElementById("centerText");
function showCenter(text){
  if(!text){ centerText.style.opacity=0; return; }
  centerText.textContent=text;
  centerText.style.opacity=1;
}

// ping
let pingMs=0; let pingT=0;
setInterval(()=>{ pingT=performance.now(); socket.emit("ping2"); },1500);
socket.on("pong2",()=> pingMs=Math.round(performance.now()-pingT));

// lobby
const panel=document.getElementById("panel");
const hostBtn=document.getElementById("hostBtn");
const genBtn=document.getElementById("genBtn");
const joinBtn=document.getElementById("joinBtn");
const roomInp=document.getElementById("roomInp");
const share=document.getElementById("share");
const status=document.getElementById("status");
const showStatus=(t)=>status.textContent=t;

let roomId=""; let side=""; let seq=0;

function joinRoom(r){
  socket.emit("room:join",{roomId:r},(res)=>{
    if(!res?.ok){ showStatus("JOIN fail: "+(res?.err||"ERR")); return; }
    roomId=res.roomId; side=res.side;
    panel.style.display="none";
  });
}

// ✅ IMPORTANT FIX: HOST will CREATE + JOIN immediately (ownership stable)
hostBtn.onclick=()=>{
  socket.emit("room:create",{},(res)=>{
    if(!res?.ok) return showStatus("Tạo phòng thất bại");
    roomId=res.roomId;
    roomInp.value=roomId;
    setHashRoom(roomId);
    joinRoom(roomId);
    showStatus("Đã HOST và vào phòng.");
  });
};

genBtn.onclick=()=>{
  const r=(roomInp.value||parseRoomFromHash()||roomId||"").toUpperCase().trim();
  if(!r) return showStatus("Chưa có ROOM. Bấm HOST trước.");
  const url=location.origin+"/#ROOM="+r;
  share.innerHTML=`<div><b>Link vào phòng:</b></div><div>${url}</div>`;
  navigator.clipboard?.writeText(url).catch(()=>{});
  showStatus("Đã copy link (nếu trình duyệt cho phép).");
};

joinBtn.onclick=()=>{
  let v=(roomInp.value||"").trim();
  if(v.includes("#")) v=v.split("#").pop();
  v=v.replace("ROOM=","").toUpperCase().trim();
  if(!v) return showStatus("Nhập ROOM hoặc dán link rồi bấm JOIN");
  setHashRoom(v);
  joinRoom(v);
};

// auto join from hash
const initialRoom=parseRoomFromHash();
if(initialRoom){ roomInp.value=initialRoom; joinRoom(initialRoom); }

// snap
socket.on("snap",(snap)=>{
  const k=0.35;

  G.phase = snap.phase || "lobby";
  G.cdText = snap.cdText || "";

  if(snap.camX!=null) G.camX = lerp(G.camX, snap.camX, k);
  if(snap.zoom!=null) G.zoom = lerp(G.zoom??1, snap.zoom, k);

  if(snap.Left){
    if(!G.Left) G.Left={...snap.Left};
    else {
      G.Left.x=lerp(G.Left.x,snap.Left.x,k);
      G.Left.y=lerp(G.Left.y,snap.Left.y,k);
      G.Left.face=snap.Left.face;
      G.Left.hp=snap.Left.hp; G.Left.maxHp=snap.Left.maxHp;
      G.Left.en=snap.Left.en; G.Left.invul=snap.Left.invul;
    }
  }
  if(snap.Right){
    if(!G.Right) G.Right={...snap.Right};
    else {
      G.Right.x=lerp(G.Right.x,snap.Right.x,k);
      G.Right.y=lerp(G.Right.y,snap.Right.y,k);
      G.Right.face=snap.Right.face;
      G.Right.hp=snap.Right.hp; G.Right.maxHp=snap.Right.maxHp;
      G.Right.en=snap.Right.en; G.Right.invul=snap.Right.invul;
    }
  }

  // FX
  if(snap.fx){
    for(const s of (snap.fx.slashes||[])) G.fx.slashes.push({...s,t:0});
    for(const p of (snap.fx.popups||[])) G.fx.popups.push({...p,t:0});
    for(const sp of (snap.fx.sparks||[])) G.fx.sparks.push({...sp,t:0});
  }

  // countdown text
  if(G.phase==="countdown") showCenter(G.cdText);
  else showCenter("");

  updateHud(pingMs);
});

// loop
let lastT=performance.now();
function loop(t){
  const dt=Math.min(0.033,(t-lastT)/1000);
  lastT=t;

  // tick FX
  for(const s of G.fx.slashes) s.t+=dt;
  for(const p of G.fx.popups) p.t+=dt;
  for(const sp of G.fx.sparks) sp.t+=dt;
  G.fx.slashes=G.fx.slashes.filter(s=>s.t<s.life);
  G.fx.popups=G.fx.popups.filter(p=>p.t<p.life);
  G.fx.sparks=G.fx.sparks.filter(sp=>sp.t<sp.life);

  // local input
  const inp=input.readLocalInput();
  const edge={
    atk: input.once("atk", inp.atk),
    dash: input.once("dash", inp.dash),
    jump: input.once("jump", inp.jump),
    s1: input.once("s1", inp.s1),
    s2: input.once("s2", inp.s2),
    ult: input.once("ult", inp.ult),
    sub: input.once("sub", inp.sub),
  };

  // ✅ do not send action during countdown if you want (optional),
  // but server already locks. This reduces spam.
  if(roomId){
    seq++;
    const send = (G.phase !== "countdown");
    socket.emit("inp",{seq, inp: send?inp:{mx:inp.mx,atk:false,jump:false,dash:false,s1:false,s2:false,ult:false,sub:false}, edge: send?edge:{}});
  }

  render.drawFrame(G,dt);
  updateHud(pingMs);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
