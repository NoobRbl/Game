<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Online 1v1 Fighter</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #wrap{position:fixed;inset:0;touch-action:none}
    canvas{position:absolute;inset:0}

    /* 16:9 hint when portrait */
    #rotateHint{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.75);color:#fff;text-align:center;padding:24px;z-index:50
    }
    @media (orientation:portrait){
      #rotateHint{display:flex}
    }

    /* top HUD */
    #hud{
      position:absolute;left:0;right:0;top:0;z-index:20;
      display:flex;gap:10px;align-items:center;justify-content:center;
      padding:10px 10px 0 10px;pointer-events:none
    }
    .barWrap{width:min(42vw,520px);height:14px;background:rgba(255,255,255,.10);border-radius:999px;overflow:hidden}
    .barFill{height:100%;width:50%}
    #hudText{color:#fff;font-weight:800;text-shadow:0 2px 10px rgba(0,0,0,.7);opacity:.95}

    /* lobby panel */
    #panel{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(560px,92vw);
      background:rgba(10,14,24,.86);backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;padding:16px;z-index:30;color:#fff
    }
    #panel h2{margin:0 0 10px 0;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input{
      flex:1;min-width:200px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      border-radius:12px;color:#fff;padding:12px 12px;outline:none
    }
    button{
      background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.14);
      color:#fff;border-radius:12px;padding:12px 14px;font-weight:800
    }
    button:active{transform:translateY(1px)}
    #share{margin-top:10px;font-size:13px;opacity:.95;line-break:anywhere}
    #status{margin-top:8px;font-size:13px;opacity:.9}

    /* controls */
    #ui{position:absolute;inset:0;z-index:10;pointer-events:none}
    #joyL{
      position:absolute;left:18px;bottom:18px;width:150px;height:150px;
      border-radius:999px;background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      pointer-events:auto;
    }
    #stickL{
      position:absolute;left:50%;top:50%;width:70px;height:70px;
      transform:translate(-50%,-50%);
      border-radius:999px;background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
    }

    .btnGrid{
      position:absolute;right:18px;bottom:18px;display:grid;
      grid-template-columns: 92px 92px;
      grid-auto-rows: 92px;
      gap:12px;pointer-events:auto;
    }
    .btn{
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      border-radius:16px;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      color:#fff;font-weight:900;user-select:none;
      box-shadow:0 12px 30px rgba(0,0,0,.35);
    }
    .btn small{opacity:.75;font-weight:800;margin-top:6px}
    .btn:active{transform:translateY(1px)}
    .btn.big{grid-column: span 2}
    #hintKeys{
      position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
      color:rgba(255,255,255,.55);font-size:12px;z-index:12;pointer-events:none
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="cv"></canvas>

  <div id="rotateHint">
    <div>
      <div style="font-size:18px;font-weight:900;margin-bottom:10px">Hãy xoay ngang để chơi 16:9</div>
      <div style="opacity:.85">Joystick + nút sẽ hoạt động mượt trong landscape.</div>
    </div>
  </div>

  <div id="hud">
    <div class="barWrap"><div id="hpL" class="barFill"></div></div>
    <div id="hudText">OFFLINE</div>
    <div class="barWrap"><div id="hpR" class="barFill"></div></div>
  </div>

  <div id="panel">
    <h2>Online 1v1</h2>
    <div class="row">
      <button id="hostBtn">HOST</button>
      <button id="genBtn">GEN LINK</button>
      <input id="roomInp" placeholder="Nhập ROOM (hoặc dán link)" />
      <button id="joinBtn">JOIN</button>
    </div>
    <div id="share"></div>
    <div id="status">Tip: bạn bè chỉ cần mở đúng link là vào luôn.</div>
  </div>

  <div id="ui">
    <div id="joyL"><div id="stickL"></div></div>

    <div class="btnGrid">
      <div class="btn" id="bUlt">ULT<small>O</small></div>
      <div class="btn" id="bJump">JUMP<small>K</small></div>

      <div class="btn" id="bSub">SUB<small>P</small></div>
      <div class="btn" id="bS2">S2<small>I</small></div>

      <div class="btn" id="bS1">S1<small>U</small></div>
      <div class="btn" id="bDash">DASH<small>L</small></div>

      <div class="btn big" id="bAtk">ATK<small>J</small></div>
    </div>

    <div id="hintKeys">WASD / Joystick • ATK J • JUMP K • DASH L • S1 U • S2 I • ULT O • SUB P</div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
/* ===== helpers ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

function parseRoomFromHash(){
  const h = location.hash.replace("#","").trim();
  if(!h) return "";
  if(h.toUpperCase().startsWith("ROOM=")) return h.slice(5).toUpperCase();
  return h.toUpperCase();
}
function setHashRoom(r){ location.hash = "ROOM=" + r; }

/* =========================
   INPUT (joystick + buttons + edge)
========================= */
function setupInput(){
  const keys = new Set();
  addEventListener("keydown",(e)=>keys.add(e.key.toLowerCase()),{passive:true});
  addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()),{passive:true});

  const touch={atk:false,dash:false,jump:false,s1:false,s2:false,ult:false,sub:false};

  const bindBtn=(id,name)=>{
    const el=document.getElementById(id);
    const down=(e)=>{ e.preventDefault(); touch[name]=true; };
    const up=(e)=>{ e.preventDefault(); touch[name]=false; };
    el.addEventListener("pointerdown",down,{passive:false});
    el.addEventListener("pointerup",up,{passive:false});
    el.addEventListener("pointercancel",up,{passive:false});
    el.addEventListener("pointerleave",up,{passive:false});
  };
  bindBtn("bAtk","atk"); bindBtn("bDash","dash"); bindBtn("bJump","jump");
  bindBtn("bS1","s1"); bindBtn("bS2","s2"); bindBtn("bUlt","ult"); bindBtn("bSub","sub");

  const joyL=document.getElementById("joyL");
  const stickL=document.getElementById("stickL");
  const joyVec={x:0,y:0};

  (function setupJoy(){
    let active=false,pid=null,center={x:0,y:0};
    const radius=52;

    function setStick(nx,ny){
      const x = nx*radius, y = ny*radius;
      stickL.style.transform=`translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
    }
    function start(e){
      active=true; pid=e.pointerId;
      const r=joyL.getBoundingClientRect();
      center.x=r.left+r.width/2; center.y=r.top+r.height/2;
      move(e);
    }
    function move(e){
      if(!active||e.pointerId!==pid) return;
      const dx=e.clientX-center.x, dy=e.clientY-center.y;
      const len=Math.hypot(dx,dy)||1;
      const k=Math.min(1,len/radius);
      joyVec.x=(dx/len)*k; joyVec.y=(dy/len)*k;
      setStick(joyVec.x,joyVec.y);
      e.preventDefault();
    }
    function end(e){
      if(!active||e.pointerId!==pid) return;
      active=false; pid=null;
      joyVec.x=0; joyVec.y=0;
      setStick(0,0);
    }

    joyL.addEventListener("pointerdown",(e)=>{
      joyL.setPointerCapture(e.pointerId);
      start(e); e.preventDefault();
    },{passive:false});
    joyL.addEventListener("pointermove",move,{passive:false});
    joyL.addEventListener("pointerup",end,{passive:false});
    joyL.addEventListener("pointercancel",end,{passive:false});
  })();

  const edgeState=new Map();
  const once=(k,down)=>{
    const prev=edgeState.get(k)||false;
    if(down && !prev){ edgeState.set(k,true); return true; }
    if(!down) edgeState.set(k,false);
    return false;
  };

  function readLocalInput(){
    let x=0;
    if(keys.has("a")) x-=1;
    if(keys.has("d")) x+=1;
    x += joyVec.x*1.05;
    x = clamp(x,-1,1);

    return {
      mx: x,
      atk:  keys.has("j") || touch.atk,
      jump: keys.has("k") || touch.jump,
      dash: keys.has("l") || touch.dash,
      s1:   keys.has("u") || touch.s1,
      s2:   keys.has("i") || touch.s2,
      ult:  keys.has("o") || touch.ult,
      sub:  keys.has("p") || touch.sub,
    };
  }

  return { readLocalInput, once };
}

/* =========================
   RENDER (16:9 + camera zoom + walls + dash afterimage)
========================= */
function setupRender() {
  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width = Math.floor(w * devicePixelRatio);
    canvas.height = Math.floor(h * devicePixelRatio);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  function computeView() {
    const W = window.innerWidth;
    const H = window.innerHeight;
    const target = 16 / 9;
    let vw = W, vh = H, ox = 0, oy = 0;

    if (W / H > target) {
      vh = H;
      vw = H * target;
      ox = (W - vw) * 0.5;
    } else {
      vw = W;
      vh = W / target;
      oy = (H - vh) * 0.5;
    }
    return { W, H, vw, vh, ox, oy };
  }

  function drawVignette(view, amount) {
    if (amount <= 0) return;
    const { ox, oy, vw, vh } = view;
    const grd = ctx.createRadialGradient(
      ox + vw / 2, oy + vh / 2, vh * 0.2,
      ox + vw / 2, oy + vh / 2, vh * 0.7
    );
    grd.addColorStop(0, `rgba(0,0,0,0)`);
    grd.addColorStop(1, `rgba(0,0,0,${0.55 * amount})`);
    ctx.fillStyle = grd;
    ctx.fillRect(ox, oy, vw, vh);
  }

  function worldToScreen(view, camX, zoom, wx, wy) {
    const { ox, oy, vw, vh } = view;
    const base = vw / 1280;
    const z = (zoom ?? 1);
    const scale = base * z;
    const sx = ox + vw / 2 + (wx - camX) * scale;
    const sy = oy + vh * 0.72 + wy * scale;
    return { sx, sy, scale };
  }

  function drawBackground(view) {
    const { ox, oy, vw, vh } = view;

    const g = ctx.createLinearGradient(0, oy, 0, oy + vh);
    g.addColorStop(0, "#0b1020");
    g.addColorStop(1, "#05070f");
    ctx.fillStyle = g;
    ctx.fillRect(ox, oy, vw, vh);

    ctx.fillStyle = "rgba(120,150,255,0.06)";
    ctx.fillRect(ox, oy + vh * 0.55, vw, vh * 0.45);

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(ox, oy + vh * 0.74, vw, vh * 0.02);

    // walls (visual)
    ctx.fillStyle = "rgba(255,255,255,0.055)";
    ctx.fillRect(ox + vw * 0.06, oy + vh * 0.55, 4, vh * 0.45);
    ctx.fillRect(ox + vw * 0.94, oy + vh * 0.55, 4, vh * 0.45);
  }

  function drawDashAfterimage(scale, isEnemy) {
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = isEnemy ? "#ff6a6a" : "#6ad5ff";
    ctx.fillRect(-26 * scale - 18, -92 * scale, 52 * scale, 92 * scale);
    ctx.globalAlpha = 1;
  }

  function drawFallbackFighter(sx, sy, face, isEnemy, scale, invul, dashHint) {
    ctx.save();
    ctx.translate(sx, sy);

    // model nhỏ
    const sizeMul = 0.78;
    ctx.scale(sizeMul, sizeMul);

    if (invul > 0) ctx.globalAlpha = 0.55 + 0.25 * Math.sin(performance.now() * 0.03);

    ctx.scale(face < 0 ? -1 : 1, 1);

    if (dashHint) drawDashAfterimage(scale, isEnemy);

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(0, 6 * scale, 28 * scale, 10 * scale, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = isEnemy ? "#ff6a6a" : "#6ad5ff";
    ctx.fillRect(-24 * scale, -92 * scale, 48 * scale, 92 * scale);

    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillRect(-14 * scale, -118 * scale, 28 * scale, 26 * scale);

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(-8 * scale, -108 * scale, 16 * scale, 3 * scale);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawFX(view, camX, zoom, fx) {
    const scaleBase = (view.vw / 1280) * (zoom ?? 1);

    for (const s of fx.slashes) {
      const p = worldToScreen(view, camX, zoom, s.wx, s.wy);
      const t = s.t / s.life;

      ctx.save();
      ctx.translate(p.sx, p.sy);
      ctx.rotate(s.rot);
      ctx.globalAlpha = 1 - t;

      let col = "rgba(190,255,255,0.9)";
      if (s.kind === "ult") col = "rgba(255,220,140,0.95)";
      if (s.kind === "skill1") col = "rgba(180,255,190,0.95)";
      if (s.kind === "skill2") col = "rgba(255,190,255,0.95)";
      if (s.kind === "sub") col = "rgba(255,255,255,0.85)";
      ctx.fillStyle = col;

      ctx.fillRect(-s.len * scaleBase * 0.5, -s.w * scaleBase * 0.5, s.len * scaleBase, s.w * scaleBase);
      ctx.restore();
    }

    for (const sp of fx.sparks) {
      const p = worldToScreen(view, camX, zoom, sp.wx, sp.wy);
      const t = sp.t / sp.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect(p.sx, p.sy, sp.s * scaleBase, sp.s * scaleBase);
    }

    ctx.textAlign = "center";
    ctx.font = `${Math.max(12, 16 * scaleBase)}px system-ui, -apple-system, Segoe UI, Roboto`;
    for (const d of fx.popups) {
      const p = worldToScreen(view, camX, zoom, d.wx, d.wy);
      const t = d.t / d.life;
      ctx.globalAlpha = 1 - t;
      ctx.fillStyle = d.crit ? "rgba(255,220,120,1)" : "rgba(255,255,255,0.95)";
      ctx.fillText(d.text, p.sx, p.sy);
    }
    ctx.globalAlpha = 1;
  }

  function drawFrame(G, dt) {
    const view = computeView();
    const { W, H, ox, oy, vw, vh } = view;

    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    const shake = G.shake || 0;
    const shx = shake ? (Math.random() - 0.5) * shake : 0;
    const shy = shake ? (Math.random() - 0.5) * shake : 0;

    ctx.save();
    ctx.translate(shx, shy);

    drawBackground(view);

    const camX = G.camX || 0;
    const zoom = (G.zoom ?? 1);

    const dashHintL = (G.Left && G.Left.invul > 0.10) || false;
    const dashHintR = (G.Right && G.Right.invul > 0.10) || false;

    if (G.Left) {
      const p = worldToScreen(view, camX, zoom, G.Left.x, G.Left.y);
      drawFallbackFighter(p.sx, p.sy, G.Left.face, false, p.scale, G.Left.invul, dashHintL);
    }
    if (G.Right) {
      const p = worldToScreen(view, camX, zoom, G.Right.x, G.Right.y);
      drawFallbackFighter(p.sx, p.sy, G.Right.face, true, p.scale, G.Right.invul, dashHintR);
    }

    drawFX(view, camX, zoom, G.fx);

    drawVignette(view, G.vignette || 0);

    if (G.flash && G.flash > 0.01) {
      ctx.globalAlpha = Math.min(0.25, G.flash);
      ctx.fillStyle = "#fff";
      ctx.fillRect(ox, oy, vw, vh);
      ctx.globalAlpha = 1;
      G.flash *= 0.85;
    }

    ctx.restore();

    if (G.shakeT > 0) {
      G.shakeT = Math.max(0, G.shakeT - dt);
      G.shake *= 0.88;
    } else {
      G.shake *= 0.90;
    }
  }

  return { drawFrame };
}

/* =========================
   NET + GAME
========================= */
const input = setupInput();
const render = setupRender();
const socket = io({ transports:["websocket","polling"] });

const G = {
  camX: 0,
  zoom: 1,
  Left: null,
  Right: null,
  fx: { slashes: [], popups: [], sparks: [] },
  shake: 0, shakeT: 0,
  vignette: 0, flash: 0,
};

const hpL = document.getElementById("hpL");
const hpR = document.getElementById("hpR");
const hudText = document.getElementById("hudText");
function setBar(el, ratio, left){
  ratio = clamp(ratio,0,1);
  el.style.width = (ratio*100).toFixed(1)+"%";
  el.style.background = left ? "linear-gradient(90deg,#49e2ff,#6a7bff)" : "linear-gradient(90deg,#ff6a6a,#ffcf6a)";
}
let pingMs = 0;
function updateHud(){
  const L = G.Left, R = G.Right;
  if(!L || !R){
    hudText.textContent = `WAITING • ping: ${pingMs}ms`;
    setBar(hpL, 0, true);
    setBar(hpR, 0, false);
    return;
  }
  setBar(hpL, (L.hp||0)/(L.maxHp||1), true);
  setBar(hpR, (R.hp||0)/(R.maxHp||1), false);
  hudText.textContent = `FIGHT • ping: ${pingMs}ms • HP: ${Math.floor(L.hp)}/${Math.floor(L.maxHp)} vs ${Math.floor(R.hp)}/${Math.floor(R.maxHp)}`;
}

// ping
let pingT=0;
setInterval(()=>{
  pingT = performance.now();
  socket.emit("ping2");
}, 1500);
socket.on("pong2", ()=> pingMs = Math.round(performance.now()-pingT));

// lobby UI
const panel = document.getElementById("panel");
const hostBtn = document.getElementById("hostBtn");
const genBtn = document.getElementById("genBtn");
const joinBtn = document.getElementById("joinBtn");
const roomInp = document.getElementById("roomInp");
const share = document.getElementById("share");
const status = document.getElementById("status");
function showStatus(t){ status.textContent = t; }

let roomId = "";
let side = "";
let seq = 0;

hostBtn.onclick = ()=>{
  socket.emit("room:create", {}, (res)=>{
    if(!res?.ok) return showStatus("Tạo phòng thất bại");
    roomId = res.roomId;
    roomInp.value = roomId;
    setHashRoom(roomId);
    showStatus("Đã HOST. Bấm GEN LINK để lấy link share.");
  });
};

genBtn.onclick = ()=>{
  const r = (roomInp.value||parseRoomFromHash()||roomId||"").toUpperCase().trim();
  if(!r) return showStatus("Chưa có ROOM. Bấm HOST trước.");
  const url = location.origin + "/#ROOM=" + r;
  share.innerHTML = `<div><b>Link vào phòng (1 code là vào luôn):</b></div><div>${url}</div>`;
  navigator.clipboard?.writeText(url).catch(()=>{});
  showStatus("Đã copy link (nếu trình duyệt cho phép). Gửi link này cho bạn bè.");
};

joinBtn.onclick = ()=>{
  let v = (roomInp.value||"").trim();
  if(v.includes("#")) v = v.split("#").pop();
  v = v.replace("ROOM=","").toUpperCase().trim();
  if(!v) return showStatus("Nhập ROOM hoặc dán link rồi bấm JOIN");
  setHashRoom(v);
  joinRoom(v);
};

function joinRoom(r){
  socket.emit("room:join", { roomId:r }, (res)=>{
    if(!res?.ok){
      showStatus("JOIN fail: " + (res?.err||"ERR"));
      return;
    }
    roomId = res.roomId;
    side = res.side;
    panel.style.display = "none";
    showStatus("OK");
  });
}

// auto join from hash
const initialRoom = parseRoomFromHash();
if(initialRoom){
  roomInp.value = initialRoom;
  joinRoom(initialRoom);
}

// snapshot
socket.on("snap", (snap)=>{
  // smooth interpolate to reduce desync feel
  const k = 0.35;

  if(snap.camX != null) G.camX = lerp(G.camX, snap.camX, k);
  if(snap.zoom != null) G.zoom = lerp(G.zoom ?? 1, snap.zoom, k);

  if(snap.Left){
    if(!G.Left) G.Left = {...snap.Left};
    else {
      G.Left.x = lerp(G.Left.x, snap.Left.x, k);
      G.Left.y = lerp(G.Left.y, snap.Left.y, k);
      G.Left.face = snap.Left.face;
      G.Left.hp = snap.Left.hp; G.Left.maxHp = snap.Left.maxHp;
      G.Left.invul = snap.Left.invul; G.Left.en = snap.Left.en;
    }
  }
  if(snap.Right){
    if(!G.Right) G.Right = {...snap.Right};
    else {
      G.Right.x = lerp(G.Right.x, snap.Right.x, k);
      G.Right.y = lerp(G.Right.y, snap.Right.y, k);
      G.Right.face = snap.Right.face;
      G.Right.hp = snap.Right.hp; G.Right.maxHp = snap.Right.maxHp;
      G.Right.invul = snap.Right.invul; G.Right.en = snap.Right.en;
    }
  }

  // FX
  if(snap.fx){
    for(const s of (snap.fx.slashes||[])) G.fx.slashes.push({...s, t:0});
    for(const p of (snap.fx.popups||[]))  G.fx.popups.push({...p, t:0});
    for(const sp of (snap.fx.sparks||[])) G.fx.sparks.push({...sp, t:0});

    if(snap.fx.ult){
      G.vignette = Math.max(G.vignette, 1.0);
      G.flash = Math.max(G.flash, 0.22);
      G.shake = Math.max(G.shake, 2.0);
      G.shakeT = Math.max(G.shakeT, 0.25);
    }
  }
});

// main loop
let lastT = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t-lastT)/1000);
  lastT = t;

  // tick FX timers + cull
  for(const s of G.fx.slashes) s.t += dt;
  for(const p of G.fx.popups)  p.t += dt;
  for(const sp of G.fx.sparks) sp.t += dt;

  G.fx.slashes = G.fx.slashes.filter(s=>s.t < s.life);
  G.fx.popups  = G.fx.popups.filter(p=>p.t < p.life);
  G.fx.sparks  = G.fx.sparks.filter(sp=>sp.t < sp.life);

  // decay vignette
  G.vignette *= 0.92;

  // input -> server
  const inp = input.readLocalInput();
  const edge = {
    atk:  input.once("atk",  inp.atk),
    dash: input.once("dash", inp.dash),
    jump: input.once("jump", inp.jump),
    s1:   input.once("s1",   inp.s1),
    s2:   input.once("s2",   inp.s2),
    ult:  input.once("ult",  inp.ult),
    sub:  input.once("sub",  inp.sub),
  };

  if(roomId){
    seq++;
    socket.emit("inp", { seq, inp, edge });
  }

  render.drawFrame(G, dt);
  updateHud();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
